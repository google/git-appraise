{"timestamp":"1461001239","author":"googlebot","description":"Thanks for your pull request.  It looks like this may be your first contribution to a Google open source project. Before we can look at your pull request, you'll need to sign a Contributor License Agreement (CLA).\n\n:memo: **Please visit \u003chttps://cla.developers.google.com/\u003e to sign.**\n\nOnce you've signed, please reply here (e.g. `I signed it!`) and we'll verify.  Thanks.\n\n---\n\n- If you've already signed a CLA, it's possible we don't have your GitHub username or you're using a different email address.  Check [your existing CLA data](https://cla.developers.google.com/clas) and verify that your [email is set on your git commits](https://help.github.com/articles/setting-your-email-in-git/).\n- If you signed the CLA as a corporation, please let us know the company's name.\n\n\u003c!-- need_sender_cla --\u003e"}

{"timestamp":"1461021996","author":"ojarjur","description":"First off, thanks for contributing. I really appreciate you taking the time and putting in the effort to make git-appraise better.\r\n\r\nThe goal of this change is very similar to the discussion we've had in [this issue](https://github.com/google/git-appraise/issues/16) regarding the long-term storage of static analysis reports.\r\n\r\nThere is definitely value in storing the raw data inside of the git repository, but there is also risk of hitting scaling issues for very large projects (whether they be large in terms of codebase, change history, or both). For example, the build and test log for [this commit](https://travis-ci.org/google/git-appraise/builds/123972642) is 273 lines long, and that's for a very simple build and test configuration. It's possible that this might still scale well if the build logs are largely similar to each other (and thus compress well), but I suspect that a lot of projects will have build logs that don't compress well (e.g. if they include a lot of data that is unique to each run, like timestamps).\r\n\r\nTo be fair, this change does make the output field optional, so each project can decide for itself whether or not to populate it, and how much data to put in there. However, I worry that it's very easy for someone to accidentally hit a scaling issue and that it will then be difficult for them to back out of said issue.\r\n\r\nAlternatively, I wonder if we can enable the following scenario:\r\n\r\n    * Some project sets up their test runners to write logs to the git repository.\r\n    * Said project runs in this configuration for a while (perhaps years) without issue\r\n    * One day their repository history with the build logs gets large enough that they hit an issue and decide they want to clear out the existing history of build logs.\r\n    * They do said clearing out, but in such a way that their high-level build status (e.g. passed vs. failed) is still maintained going back to the beginning of the repository.\r\n\r\nE.G. I'd like it if a user could easily drop their build-and-test detailed history while still maintaining the summaries.\r\n\r\nWhat do you think about the idea of storing the logs under a new git ref (for instance, something under the namespace \"refs/notes/devtoolsdetailed/\"), and then making the existing CI object include a reference to that?\r\n\r\nI will concede that this would be a much larger change than the current proposal, so I understand if you don't have time to get to that, but I do think it would be a safer change in the long run.\r\n\r\nThere's also some ambiguity here about how the detailed logs should be stored. For instance, it could be a single ref holding all logs, or separate refs. I suspect our best bet would be to let the build runner define that, and make the CI object specify enough information to support multiple scenarios. If we go with this route, then I think the minimum amount of information the CI object would have to store is:\r\n\r\n1. The SHA1 hash of the git object holding the build-and-test logs.\r\n2. The name of a git ref that can be fetched in order to pull down said object.\r\n\r\nWhat do you think?"}

{"timestamp":"1461022190","author":"ojarjur","location":{"commit":"62ca34bf78cfccfc0c52ab44516df26d692614da","path":"commands/output/output.go","range":{"startLine":182}},"description":"This should probably not be displayed by default (that would be very verbose), but rather limited to the case of a user passing in a special flag.\r\n\r\nSpecifically, I mean something like what we are doing for displaying a diff only if the `--diff` flag is passed in."}

{"timestamp":"1461161282","author":"lollipopman","location":{"commit":"62ca34bf78cfccfc0c52ab44516df26d692614da","path":"commands/output/output.go","range":{"startLine":182}},"description":"\u003e This should probably not be displayed by default (that would be very verbose), but rather limited to the case of a user passing in a special flag.\r\n\r\n\u003e Specifically, I mean something like what we are doing for displaying a diff only if the --diff flag is passed in.\r\n\r\nThat makes sense, I will add an appropriate flag"}

{"timestamp":"1461161835","author":"lollipopman","description":"\u003e What do you think about the idea of storing the logs under a new git ref (for instance, something under the namespace \"refs/notes/devtoolsdetailed/\"), and then making the existing CI object include a reference to that?\r\n\r\nThat makes sense, would you be okay with storing those detailed notes as plain text? I was intending to have my static analysis tool, in this case puppet, create a puppet noop output for each commit. I would then like to be able to view each individual commit along with the ci output, using just `git log --notes=refs/notes/devtoolsdetailed`.\r\n\r\n\u003e I will concede that this would be a much larger change than the current proposal, so I understand if you don't have time to get to that, but I do think it would be a safer change in the long run.\r\n\r\nI am willing to give it a go.\r\n\r\n\u003e There's also some ambiguity here about how the detailed logs should be stored. For instance, it could be a single ref holding all logs, or separate refs. I suspect our best bet would be to let the build runner define that, and make the CI object specify enough information to support multiple scenarios. If we go with this route, then I think the minimum amount of information the CI object would have to store is:\r\n\u003e \r\n\u003e The SHA1 hash of the git object holding the build-and-test logs.\r\n\u003e The name of a git ref that can be fetched in order to pull down said object.\r\n\u003e What do you think?\r\n\r\nWhat about an array of refs \u0026 an array of SHA1 hashes?"}

{"timestamp":"1461161836","author":"googlebot","description":"CLAs look good, thanks!\n\n\u003c!-- ok --\u003e"}
